<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YouTube Random & Shuffle Player — 200+ pagination</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#121923; --muted:#9fb0c0; --text:#eaf1f8; --accent:#67e8f9; --accent2:#a78bfa; --danger:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
  .title{font-size:1.6rem;font-weight:700;margin-bottom:12px}
  .card{background:var(--panel);border:1px solid #1f2937;border-radius:16px;box-shadow:0 8px 30px rgba(0,0,0,.25);padding:16px;margin-bottom:16px}
  label{font-size:.9rem;color:var(--muted);display:block;margin:8px 0 6px}
  input[type="text"], input[type="password"], input[type="number"]{
    width:100%;padding:12px 14px;border-radius:12px;border:1px solid #243043;background:#0e1520;color:var(--text);outline:none
  }
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .row > *{flex:1 1 280px}
  .btn{
    background:linear-gradient(135deg,var(--accent),var(--accent2));color:#071018;border:none;
    padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;transition:transform .05s ease;
  }
  .btn:active{transform:translateY(1px)}
  .btn.secondary{background:#1f2a37;color:var(--text);border:1px solid #2b3a4e}
  .btn.danger{background:var(--danger);color:#140b0b}
  .controls{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
  .pill{display:inline-flex;align-items:center;gap:8px;background:#152030;border:1px solid #253247;color:var(--text);padding:8px 12px;border-radius:999px}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px;margin-top:12px}
  .item{display:flex;gap:10px;background:#0f1623;border:1px solid #243245;border-radius:12px;padding:10px;cursor:pointer}
  .thumb{width:96px;height:54px;border-radius:8px;object-fit:cover;background:#000}
  .meta{display:flex;flex-direction:column;gap:4px}
  .meta .t{font-weight:600;line-height:1.2}
  .meta .c{font-size:.85rem;color:var(--muted)}
  .badge{font-size:.75rem;color:#0b1018;background:#c1f4ff;border-radius:999px;padding:2px 8px;align-self:flex-start}
  .stat{color:var(--muted);font-size:.9rem}
  .footer{margin-top:10px;color:var(--muted);font-size:.85rem}
  .divider{height:1px;background:#1f2a37;margin:12px 0}
  .player-wrap{position:relative;border-radius:16px;overflow:hidden;border:1px solid #1f2937}
  .hint{font-size:.85rem;color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <div class="title">YouTube Random & Shuffle Player</div>

    <div class="card">
      <div class="row">
        <div>
          <label>API Key</label>
          <input id="apiKey" type="password"
            value="AIzaSyAFKFkqiUFf12oDaFIV54Vf6b-FirJRDt0"
            placeholder="Paste your YouTube Data API v3 key"/>
          <div class="hint">Client code exposes keys. Use a server proxy for production.</div>
        </div>
        <div>
          <label>Search URL <em>or</em> Query</label>
          <input id="queryInput" type="text"
            placeholder='Paste: https://www.youtube.com/results?search_query=%22.avi%22+or+%22.img_1237%22+or+%22.mvi_2419%22  — or type: ".avi" OR "img_1237" OR "mvi_2419"'/>
        </div>
        <div>
          <label>Batch size (videos per “Load more”)</label>
          <input id="batchSize" type="number" min="50" step="50" value="200"/>
          <div class="hint">YouTube returns up to 50 per call; we paginate to reach this number.</div>
        </div>
      </div>
      <div class="controls">
        <button class="btn" id="fetchBtn">Fetch (first 200)</button>
        <button class="btn secondary" id="loadMoreBtn" disabled>Load +200</button>
        <button class="btn secondary" id="randomBtn" disabled>Play Random</button>
        <button class="btn secondary" id="nextBtn" disabled>Next (Shuffle)</button>
        <span class="pill"><input type="checkbox" id="shuffleChk" checked/> Shuffle queue</span>
        <span class="pill"><input type="checkbox" id="autoNextChk" checked/> Auto-next on end</span>
        <span class="pill"><input type="checkbox" id="shortsFilterChk"/> Hide Shorts (&lt;60s)</span>
      </div>
      <div class="divider"></div>
      <div class="row">
        <div class="stat">Total unique loaded: <span id="count">0</span></div>
        <div class="stat">Visible (after filters): <span id="visibleCount">0</span></div>
        <div class="stat">Queue left: <span id="left">0</span></div>
        <div class="stat" id="exhaustNote"></div>
      </div>
    </div>

    <div class="card player-wrap">
      <div id="player" style="aspect-ratio:16/9;width:100%;"></div>
    </div>

    <div class="card">
      <div class="row">
        <div class="stat">Results</div>
        <div class="hint">Click any item to play. “Next” uses a no-repeat shuffled queue.</div>
      </div>
      <div id="results" class="grid"></div>
      <div class="footer">Tip: You can paste a <strong>YouTube search URL</strong> or just type a query using OR, e.g. <code>".avi" OR "img_1237" OR "mvi_2419"</code>.</div>
    </div>
  </div>

  <!-- YouTube IFrame Player API -->
  <script>
  // Load IFrame API
  (function(){ const s=document.createElement('script'); s.src="https://www.youtube.com/iframe_api"; document.head.appendChild(s); })();

  let player;              // YT.Player instance
  let items = [];          // all unique results [{id, title, channel, thumb, durationSec?}]
  let displayItems = [];   // filtered (e.g., hide shorts)
  let queue = [];          // shuffled queue of ids
  let qPtr = 0;            // queue pointer

  // Search state for pagination across terms
  const searchState = {
    key: '',
    terms: [],
    nextTokens: new Map(),   // term -> nextPageToken (string or null if none yet)
    exhausted: new Set(),    // terms with no more pages
    itemsById: new Map(),    // id -> item
  };

  function onYouTubeIframeAPIReady(){
    player = new YT.Player('player', {
      playerVars: { rel: 0, modestbranding: 1 },
      events: { 'onStateChange': onPlayerStateChange }
    });
  }
  function onPlayerStateChange(e){
    const auto = document.getElementById('autoNextChk').checked;
    if (auto && e.data === YT.PlayerState.ENDED) playNext();
  }

  // Helpers
  const $ = s => document.querySelector(s);
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const chunk = (arr, n) => Array.from({length: Math.ceil(arr.length/n)}, (_,i)=>arr.slice(i*n, i*n+n));
  function escapeHTML(s){ return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;' }[m])); }

  function parseInputToTerms(input){
    if(!input) return [];
    let raw = input.trim();
    try{
      if (raw.includes('youtube.com/results')) {
        const u = new URL(raw);
        raw = u.searchParams.get('search_query') || raw;
      }
    }catch(_){}
    raw = decodeURIComponent(raw.replace(/\+/g,' '));
    const parts = raw.split(/\s+or\s+/i).map(s=>s.trim()).filter(Boolean);
    const terms = (parts.length ? parts : [raw]).map(t=>{
      const m = t.match(/^"(.*)"$/); return (m ? m[1] : t).trim();
    });
    return Array.from(new Set(terms.filter(Boolean)));
  }

  async function searchOnce(term, key, pageToken){
    const base = 'https://www.googleapis.com/youtube/v3/search';
    const url = new URL(base);
    url.searchParams.set('part','snippet');
    url.searchParams.set('type','video');
    url.searchParams.set('videoEmbeddable','true');
    url.searchParams.set('maxResults','50');
    url.searchParams.set('q', term);
    if (pageToken) url.searchParams.set('pageToken', pageToken);
    url.searchParams.set('key', key);
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Search failed (${res.status}) for "${term}"`);
    const data = await res.json();
    const vids = (data.items||[])
      .map(it=>({
        id: it.id?.videoId,
        title: it.snippet?.title || 'Untitled',
        channel: it.snippet?.channelTitle || 'Unknown',
        thumb: it.snippet?.thumbnails?.medium?.url || it.snippet?.thumbnails?.default?.url || ''
      }))
      .filter(v=>v.id);
    return { vids, nextPageToken: data.nextPageToken || null };
  }

  function ISO8601DurationToSeconds(iso){
    const m = iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if(!m) return 0; const h=+m[1]||0, mn=+m[2]||0, s=+m[3]||0; return h*3600+mn*60+s;
  }

  async function fetchDurations(ids, key){
    const base = 'https://www.googleapis.com/youtube/v3/videos';
    const results = {};
    for (const group of chunk(ids, 50)){
      const url = new URL(base);
      url.searchParams.set('part','contentDetails');
      url.searchParams.set('id', group.join(','));
      url.searchParams.set('key', key);
      const res = await fetch(url);
      if (!res.ok) continue;
      const data = await res.json();
      (data.items||[]).forEach(v=>{
        results[v.id] = ISO8601DurationToSeconds(v.contentDetails?.duration || 'PT0S');
      });
      await sleep(60);
    }
    return results;
  }

  async function ensureDurationsFor(itemList){
    // Fetch durations for items missing it (used by Shorts filter)
    const key = searchState.key;
    const missing = itemList.filter(v => typeof v.durationSec !== 'number').map(v=>v.id);
    if (!missing.length) return;
    const map = await fetchDurations(missing, key);
    itemList.forEach(v => { if (map[v.id] != null) v.durationSec = map[v.id]; });
  }

  function renderResults(list){
    const cont = $('#results');
    cont.innerHTML = '';
    list.forEach(v=>{
      const el = document.createElement('div');
      el.className = 'item';
      el.innerHTML = `
        <img class="thumb" src="${v.thumb}" alt="">
        <div class="meta">
          <div class="t">${escapeHTML(v.title)}</div>
          <div class="c">${escapeHTML(v.channel)}</div>
          ${typeof v.durationSec === 'number' ? `<span class="badge">${formatTime(v.durationSec)}</span>` : ``}
        </div>`;
      el.addEventListener('click', ()=> playVideo(v.id));
      cont.appendChild(el);
    });
    $('#count').textContent = String(items.length);
    $('#visibleCount').textContent = String(list.length);
  }

  function formatTime(sec){
    sec = Math.max(0, Math.floor(sec));
    const h = Math.floor(sec/3600), m = Math.floor((sec%3600)/60), s = sec%60;
    return (h?`${h}:`:'') + (h?String(m).padStart(2,'0'):m) + ':' + String(s).padStart(2,'0');
  }

  function buildQueue(fromItems, shuffle=true){
    queue = fromItems.map(v=>v.id);
    if (shuffle) {
      for (let i=queue.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [queue[i],queue[j]]=[queue[j],queue[i]]; }
    }
    qPtr = 0; updateLeft();
  }
  function updateLeft(){ $('#left').textContent = String(Math.max(0, queue.length - qPtr)); }
  function playVideo(id){ if (player) player.loadVideoById(id); }
  function playRandom(){ if (!displayItems.length) return; const idx = Math.floor(Math.random()*displayItems.length); playVideo(displayItems[idx].id); }
  function playNext(){
    if (!queue.length) return;
    if (qPtr >= queue.length) buildQueue(displayItems, $('#shuffleChk').checked);
    const id = queue[qPtr++]; updateLeft(); playVideo(id);
  }

  function computeDisplayItems(){
    const hideShorts = $('#shortsFilterChk').checked;
    displayItems = hideShorts ? items.filter(v => (v.durationSec ?? 9999) >= 60) : items.slice();
    renderResults(displayItems);
    buildQueue(displayItems, $('#shuffleChk').checked);
    const exhausted = searchState.exhausted.size === searchState.terms.length;
    $('#loadMoreBtn').disabled = exhausted;
    $('#exhaustNote').textContent = exhausted ? 'No more pages from YouTube for these terms.' : '';
    const hasAny = displayItems.length > 0;
    $('#randomBtn').disabled = !hasAny;
    $('#nextBtn').disabled = !hasAny;
  }

  async function loadBatch(targetCount){
    // Round-robin across terms until we add targetCount new uniques or run out
    const terms = searchState.terms;
    const key = searchState.key;

    let added = 0;
    if (!terms.length) throw new Error('No terms to search.');

    while (added < targetCount){
      let progressed = false;
      for (const term of terms){
        if (searchState.exhausted.has(term)) continue;
        const token = searchState.nextTokens.get(term) || undefined;
        const { vids, nextPageToken } = await searchOnce(term, key, token);
        // Update paging
        if (nextPageToken) { searchState.nextTokens.set(term, nextPageToken); }
        else { searchState.nextTokens.delete(term); searchState.exhausted.add(term); }

        // Merge uniques
        let newFromThisCall = 0;
        for (const v of vids){
          if (!searchState.itemsById.has(v.id)){
            searchState.itemsById.set(v.id, v);
            items.push(v);
            added++; newFromThisCall++;
            if (added >= targetCount) break;
          }
        }
        if (newFromThisCall > 0) progressed = true;

        if (added >= targetCount) break;

        await sleep(60); // tiny spacing
      }
      // If a full pass added nothing, we’re done
      if (!progressed) break;
    }
    return added;
  }

  async function fetchFirstBatch(){
    // Reset state, then fetch initial N (default 200)
    const key = $('#apiKey').value.trim();
    const input = $('#queryInput').value.trim();
    const batchSize = Math.max(50, parseInt($('#batchSize').value||200,10));
    if (!key) { alert('Please paste your YouTube API key.'); return; }
    if (!input) { alert('Please enter a YouTube search URL or a query.'); return; }

    setLoading(true, 'fetchBtn', 'Fetch (first 200)');
    try{
      // Init state
      items = [];
      displayItems = [];
      queue = [];
      qPtr = 0;
      searchState.key = key;
      searchState.terms = parseInputToTerms(input);
      if (!searchState.terms.length) throw new Error('Could not parse any query terms.');
      searchState.nextTokens = new Map(searchState.terms.map(t=>[t, undefined]));
      searchState.exhausted = new Set();
      searchState.itemsById = new Map();

      const added = await loadBatch(batchSize);
      if (!added){
        renderResults([]); computeDisplayItems();
        alert('No results found for that query.');
        return;
      }

      if ($('#shortsFilterChk').checked) { await ensureDurationsFor(items); }
      computeDisplayItems();
      // Auto-play one
      if (displayItems.length) playNext();
    }catch(err){
      console.error(err);
      alert(err.message || String(err));
    }finally{
      setLoading(false, 'fetchBtn', 'Fetch (first 200)');
    }
  }

  async function loadMore(){
    const batchSize = Math.max(50, parseInt($('#batchSize').value||200,10));
    setLoading(true, 'loadMoreBtn', 'Loading…');
    try{
      const before = items.length;
      const added = await loadBatch(batchSize);
      if (!added) {
        computeDisplayItems();
        alert('No more pages available for these terms.');
        return;
      }
      // Fetch durations for just the new items if Shorts filter is on
      if ($('#shortsFilterChk').checked) {
        const newOnes = items.slice(before);
        await ensureDurationsFor(newOnes);
      }
      computeDisplayItems();
    }catch(err){
      console.error(err);
      alert(err.message || String(err));
    }finally{
      setLoading(false, 'loadMoreBtn', 'Load +' + batchSize);
    }
  }

  // UI wiring
  $('#fetchBtn').addEventListener('click', fetchFirstBatch);
  $('#loadMoreBtn').addEventListener('click', loadMore);
  $('#randomBtn').addEventListener('click', playRandom);
  $('#nextBtn').addEventListener('click', playNext);
  $('#shuffleChk').addEventListener('change', ()=>{ if (displayItems.length) buildQueue(displayItems, $('#shuffleChk').checked); });
  $('#shortsFilterChk').addEventListener('change', async ()=>{
    if ($('#shortsFilterChk').checked) await ensureDurationsFor(items);
    computeDisplayItems();
  });

  function setLoading(on, id, label){
    const btn = document.getElementById(id);
    btn.disabled = on;
    if (id==='fetchBtn') btn.textContent = on ? 'Fetching…' : label;
    if (id==='loadMoreBtn') btn.textContent = on ? 'Loading…' : label;
  }
  </script>
</body>
</html>
